## babel parser 对 estree AST 的扩展
babel 基于 acorn 插件对 estree AST 做了如下扩展
- 把 Literal 替换成了 StringLiteral、NumericLiteral、 BigIntLiteral、 BooleanLiteral、 NullLiteral、 RegExpLiteral
- 把 Property 替换成了 ObjectProperty 和 ObjectMethod
- 把 MethodDefinition 替换成了 ClassMethod
- Program 和 BlockStatement 支持了 directives 属性，也就是 'use strict' 等指令的解析，对应的 ast 是 Directive 和 DirectiveLiteral
- ChainExpression 替换为了 ObjectMemberExpression 和 OptionalCallExpression
- ImportExpression 替换为了 CallExpression 并且 callee 属性设置为 Import

这些可以在 [babel parser 的文档](https://babeljs.io/docs/en/babel-parser#output)里看到。

## acorn插件
acorn 主要是一个 Parser 类，不同的方法实现了不同的逻辑，插件扩展就是继承这个 Parser，重写一些方法

acorn 的 api 如下，其中 `acorn-jsx`、`acorn-bigint` 就是 acorn 插件

```js
const { Parser } = require("acorn")

const MyParser = Parser.extend(
  require("acorn-jsx")(),
  require("acorn-bigint")
)
console.log(MyParser.parse("// Some bigint + JSX code"))
```

插件是一个函数，接收之前的 Parser，返回扩展以后的 Parser

```js
module.exports = function noisyReadToken(Parser) {
  return class extends Parser {
    readToken(code) {
      console.log("Reading a token!")
      super.readToken(code)
    }
  }
}
```

## 实例
> 给 javascript 一个关键字 jiang，可以作为 statement 单独使用

我们知道 parse 的过程其实就是`分词` + `组装 AST`这两步（一般叫`词法分析`和`语法分析`），我们只要实现这两步就可以了。

#### 分词（词法分析）
1. 我们是想增加一个关键字，acorn 有 keywords 属性，是一个正则表达式，用来做关键字拆分，所以我们重写 keywords 属性就可以。
2. 并且还要为新的关键字注册一个 token 类型。


```js
// step1: acorn Parser 的入口方法是 parse，我们要在 parse 方法里面设置 keywords。
parse(program) {
    var newKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this const class extends export import super";
    newKeywords += "jiang";// 增加一个关键字
    this.keywords = new RegExp("^(?:" + newKeywords.replace(/ /g, "|") + ")$")

    return(super.parse(program));
}

// step2: 然后注册一个新的 token 类型来标识它
Parser.acorn.keywordTypes["jiang"] = new TokenType("jiang",{keyword: "jiang"});
```

#### 组装AST（语法分析）
光分出 token 是没意义的，要组装到 AST 中。

acorn 在 parse 到不同类型的节点会调用不同的 parseXxx 方法，因为我们是在 statement 里面用，那么就要重写 parseStatement 方法，在里面组装新的 statement 节点。

```js
parseStatement(context, topLevel, exports) {
  // this.type 是当前处理到的 token 的类型
  var tokenType = this.type;

  // 如果不是我们扩展的 token，则调用父类的 parseStatement 处理
  if (tokenType == Parser.acorn.keywordTypes["jiang"]) {
    // 通过 this.startNode()创建一个新的AST节点，然后 this.next()消费掉这个token，之后返回新的AST节点。
    var node = this.startNode();
    this.next();
    return this.finishNode({value: 'jiang'},'JiangStatement');
  }
  else {
    return(super.parseStatement(context, topLevel, exports));
  }
}
```

这样能成功分出token，但是最好把它独立成一个方法，这样子类可以覆盖这个方法来对 parse 逻辑做修改。

```js
parseStatement(context, topLevel, exports) {
  var tokenType = this.type;

  if (tokenType == Parser.acorn.keywordTypes["jiang"]) {
    var node = this.startNode();
    return this.parseJiangStatement(node);
  }
  else {
    return(super.parseStatement(context, topLevel, exports));
  }
}

parseJiangStatement(node) {
    this.next();
    return this.finishNode({value: 'jiang'},'JiangStatement');
}
```

完整代码如下：
```js
const acorn = require("acorn");

const Parser = acorn.Parser;
const tt = acorn.tokTypes; 
const TokenType = acorn.TokenType;

Parser.acorn.keywordTypes["jiang"] = new TokenType("jiang",{keyword: "jiang"});

function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
}

var jiangKeyword = function(Parser) {
  return class extends Parser {
    parse(program) {
      let newKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this const class extends export import super";
      newKeywords += " jiang";
      this.keywords = new RegExp("^(?:" + newKeywords.replace(/ /g, "|") + ")$")
      return(super.parse(program));
    }

    parseStatement(context, topLevel, exports) {
      var starttype = this.type;

      if (starttype == Parser.acorn.keywordTypes["jiang"]) {
        var node = this.startNode();
        return this.parseJiangStatement(node);
      }
      else {
        return(super.parseStatement(context, topLevel, exports));
      }
    }

    parseJiangStatement(node) {
      this.next();
      return this.finishNode({value: 'jiang'},'JiangStatement');//新增加的ssh语句
    };
  }
}
const newParser = Parser.extend(jiangKeyword);
```

我们执行下试下效果

```js
const newParser = Parser.extend(jiangKeywordPlugin);

var program = 
`
    jiang
    const a = 1
`;

const ast = newParser.parse(program);
console.log(ast);
```

babel的 Literal 扩展了 StringLiteral、NumericLiteral 等这一点，我们就可以自己实现：

```js
parseLiteral (...args) {
    const node = super.parseLiteral(...args);
    switch(typeof node.value) {
        case 'number':
            node.type = 'NumericLiteral';
            break;
        case 'string':
            node.type = 'StringLiteral';
            break;
    }
    return  node;
}
```

