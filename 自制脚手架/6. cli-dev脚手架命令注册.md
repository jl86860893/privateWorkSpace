## cli-dev脚手架命令注册

```js
'use strict';

module.exports = core;
const path = require('path')
const semver = require('semver');
const commander = require('commander');
const colors = require('colors/safe');
const userHome = require('user-home');
const pathExists = require('path-exists').sync;
const pkg = require('../package.json');
const log = require('@ijianglu/log')
const init = require('@ijianglu/init')
const constant = require('./const')

const program = new commander.Command()

async function core() {
    try {
        await prepare()
        registerCommand()
    } catch (e) {
        log.error(e.message)
        if (program.debug) {
            console.log(e);
        }
    }
}

function registerCommand() {
    program
        .name(Object.keys(pkg.bin)[0])
        .usage('<command> [options]')
        .version(pkg.version)
        .option('-d, --debug', '是否开启调试模式', false)
        .option('-tp, --targetPath <targetPath>', '是否指定本地调试文件路径', '');
    
    program
        .command('init [projectName]')
        .option('-f, --force', '是否强制初始化项目')
        .action(init);
    // 获取options参数
	const options = program.opts();
    program.on('option:debug', function(){
        if (options.debug) {
            process.env.LOG_LEVEL = 'verbose'
        } else {
            process.env.LOG_LEVEL = 'info'
        }
        log.level = process.env.LOG_LEVEL;
    });

    // 指定targetPath
    program.on('option:targetPath', function() {
        process.env.CLI_TARGET_PATH = options.targetPath;
    });

    // 对未知命令监听
    program.on('command:*', function(obj) {
        const availableCommands = program.commands.map(cmd => cmd.name());
        console.log(colors.red('未知的命令：' + obj[0]));
        if (availableCommands.length > 0) {
        console.log(colors.red('可用命令：' + availableCommands.join(',')));
        }
    });

    program.parse(process.argv);

    if (program.args && program.args.length < 1) {
        program.outputHelp();
        console.log();
    }
}

async function prepare() {
    checkNodeVersion()
    checkPkgVersion();
    checkRoot();
    // checkInputArgs
    checkUserHome();
    checkEnv();
    await checkGlobalUpdate();
}

// 省略准备阶段......
```

此时将初始化init命令于commands/init中执行

```js
'use strict';

// 此处形参与commander注册命令的action参数一致
function init(projectName, cmdObj) {
    // -tp命令的option在根上（所以用cmdObj.parent），init的option在当前对象上
    console.log('init', projectName, cmdObj.force, cmdObj.parent.targetPath)
}

module.exports = init;
```

但是这样存在问题：

1. core/cli安装速度慢： 所有package都集成在cli里，因此当命令较多时，会减慢cli安装速度

2. 灵活性差： init命令只能使用`@ijianglu/init`包，对于集团公司而言，每个bu的init命令可能都各不相同，可能需要实现init命令动态化，如：

   - 团队A使用`@ijianglu/init`作为初始化模块
   - 团队B使用自己开发的`@ijianglu/my-init`作为初始化模块
   - 团队C使用自己开发的`@ijianglu/mymy-init`作为初始化模块

   这时希望能动态加载init模块，将增加架构复杂度。但这样做能够提升脚手架可扩展性，将脚手架框架和业务逻辑解耦



优化架构图见下一篇

