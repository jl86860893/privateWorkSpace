# lerna简介
## 原生脚手架痛点
- 痛点一： 重复操作  
  - 多package本地link
  - 多package依赖安装
  - 多package单元测试
  - 多package代码提交
  - 多package代码发布
- 痛点二： 版本一致性
  - 发布时版本一致性
  - 发布后相互依赖版本升级

> package越多版本复杂性越高

## 简介
基于npm+npm的多package项目的管理工具
### 优势
- 大幅减少重复操作
- 提升操作的标准化

> Lerna是架构优化的产物，它揭示了一个架构真理：项目复杂度提升后，就需要对项目进行架构优化。架构优化的主要目标往往都是以<font color="red">效能</font>核心

# 脚手架的实现原理
## 脚手架实现原理
请回答：
1. 为什么全局安装`@vue/cli`后会添加的命令为`vue`?

   > npm i -g @vue/cli

  &nbsp;&nbsp;&nbsp;&nbsp;<font color="green">因为在安装目录的package.json中的bin实现对vue的软链接</font>

​     ![1.png](./pic/lerna简介/1.png)

2. 全局安装`@vue/cli`时发生了什么？

   >  先找package.json下的bin配置；如果发现该配置则会安装目录的bin目录下创建软链接到真实文件路径

3. 执行`vue`命令时发生了什么？为什么`vue`指向一个`js`文件，我们却可以直接通过`vue`命令去执行它？

   > 执行vue时是在环境变量中找到vue的软链接最终找到真实文件路径；然后执行该vue.js文件
   >
   > node vue.js可以执行js文件；但是直接输入vue就执行；原因是：文件开头为“   #!/usr/bin/env node   ” 则可将此文件用nodejs执行



## 脚手架原理进阶

回答问题：

1. 为什么说脚手架本质是操作系统的客户端？它和我们在PC上安装的应用/软件有什么区别？  

   > 因为他靠node去执行，依赖操作系统的node环境

2. 如何为node脚手架命令创建别名

   > ln -s vue2 ./vue   
   > 此处./vue中的./为软链接所在路径；执行ln时路径所处原点为软链接所存放的位置

3. 描述脚手架命令运行的全过程
   ![](./pic/lerna简介/2.png)



## 脚手架的开发流程

### 脚手架开发流程详解

#### 开发流程

- 创建`npm`项目

- 创建脚手架入口文件，最上方添加：

  > #!在  Linux中称为“释伴”

  ```js
  #!/usr/bin/env node
  // 在windows系统中不生效；需要将node添加到环境变量
  #!node
  ```

  > // 注意：安装可能不在bin下因此找不到命令时执行：sudo ln -s which nodejs /usr/bin/node

- 配置`package.json`，添加`bin`属性

- 编写脚手架代码

- 将脚手架发布到`npm`

#### 使用流程

- 安装脚手架

  > npm install -g your-own-cli

- 使用脚手架

  > your-own-cli

## 脚手架开发难点解析

- 分包：将复杂的系统拆分成若干个模块

- 命令注册

  ```shell
  vue create
  vue add
  vue invoke
  ```

- 参数解析：

  ```bash
  vue command [options] <params>
  ```

  - options全称： `--version`、`--help`

  - options简写： `-v`、`-h`

  - 带params的options： `--path /Users/jiang/Desktop/vue-test`

  - 帮助文档：

    - global help
      - Usage
      - Options

  - 帮助文档示例

    ```bash
    Usage: vue <command> [options]
    
    Options:
      -V, --version                              output the version number
      -h, --help                                 output usage information 
    
    Commands:
      create [options] <app-name>                create a new project powered by vue-cli-service
      add [options] <plugin> [pluginOptions]     install a plugin and invoke its generator in an already created project
      invoke [options] <plugin> [pluginOptions]  invoke the generator of a plugin in an already created project
      inspect [options] [paths...]               inspect the webpack config in a project with vue-cli-service
      serve [options] [entry]                    serve a .js or .vue file in development mode with zero config
      build [options] [entry]                    build a .js or .vue file in production mode with zero config
      ui [options]                               start and open the vue-cli ui     
      init [options] <template> <app-name>       generate a project from a remote template (legacy API, requires @vue/cli-init)
      config [options] [value]                   inspect and modify the config     
      outdated [options]                         (experimental) check for outdated 
    vue cli service / plugins
      upgrade [options] [plugin-name]            (experimental) upgrade vue cli service / plugins
      migrate [options] [plugin-name]            (experimental) run migrator for an already-installed cli plugin
      info                                       print debugging information about 
    your environment
    
      Run vue <command> --help for detailed usage of given command.
    ```

其他难点：

- 命令行交互

- 日志打印

- 命令行文字变色

- 网络通信： HTTP/WebSocket

- 文件处理

  等等。。。。。。



## 脚手架开发流程

![](.\pic\lerna简介\3.png)

#### 开发流程
- 创建npm项目
- 创建脚手架入口文件，最上方添加
> #!/usr/bin/env/node
- 配置`package.json`添加`bin`属性
- 编写脚手架代码
- 发布到npm

#### 使用流程
- 安装脚手架
> npm install -g tool-test
- 使用脚手架
> tool-test



## 调试脚手架

##### 单包调试

1. <font color="red">发布</font>脚手架后，在脚手架所在目录`npm i -g JSJ`；此时会自动将脚手架连接到当前目录下的脚手架;此时则可以调试

   >  若想不使用本地的，则可以在其他目录下执行`npm i -g JSJ`;此时不可本地调试

2. <font color="red">不发布情况下</font>，只需在架手架所在目录执行`npm link`即可 

##### 多包调试

*不发布即可调试*

![](.\pic\lerna简介\4.png)

发布上线前，手动在tool的package.json中添加依赖

```
"dependencies": {
	"tool-lib": "^1.0.0"
}
```



#### 脚手架本地link标准流程

**连接本地脚手架**

```
cd your-cli-dir
npm link
```

**链接本地库文件**：

```
cd your-lib-dir
npm link
cd your-cli-dir
npm link your-lib
```

**取消链接本地库文件**
```
cd your-lib-dir
npm unlink
cd your-cli-dir
# link存在
npm unlink your-lib
# link不存在
rm -rf node_modules
npm install -S your-lib
```

理解npm link：
- `npm link your-lib`：将当前项目中`node_modules`下指定的库文件链接到node全局node_modules下的库文件
- `npm link`: 将当前项目链接到node_module中作为一个库文件，并解析bin配置创建可执行文件



## 命令注册与参数解析

1. 注册命令

   > 命令参数获取：
   >
   > ![](.\pic\lerna简介\5.png)

2. 实现参数解析

   ![](.\pic\lerna简介\6.png)



# lerna流程

脚手架项目初始化
```
初始化npm项目

安装lerna

lerna init初始化项目
```

创建package
```shell
lerna create创建package

lerna add安装依赖（全部包）
 
lerna link链接依赖
```
> lerna add -h 可以显示以下提示  
lerna add module-1 packages/prefix-*(安装道packages下的`prefix-*目录名`下)   
lerna add module-1 --scope=module-2(安装module1到module2)  
...

脚手架开发测试
```shell
lerna exec -- 执行shell脚本

lerna run执行npm命令： 
lerna run build
lerna run --scope @jianglu/utils build

lerna clean 清空依赖（全部包）

lerna bootstrap重装依赖
```
> lerna exec -- rm -rf node_modules/   删除`packages`下的所有node_modules  
lerna exec --scope module-1 --rm -rf node_modules/   删除`module-1包名`下的node_modules

> lerna run test  
lerna run --scope module-1 test

脚手架发布上线
```shell
lerna version
bump version

lerna changed查看上版本以来的所有变更

lerna diff查看diff

lerna publish项目发布
```

publish时需要注意
因为发布到@jianglu的Group上，需要在每个package.json下添加

```shell
"publishConfig": {
    "access": "public"
  },
```