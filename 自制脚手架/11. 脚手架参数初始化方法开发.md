**tips**

>每新建一个promise异步，在promise异步中报的错不会在promise外部捕获
>
>```js
>'use strict';
>
>const path = require('path');
>const Package = require('@ijianglu/package');
>const log = require('@ijianglu/log');
>// const { exec: spawn } = require('@ijianglu/utils');
>
>const SETTINGS = {
>  init: '@ijianglu/init',
>};
>
>const CACHE_DIR = 'dependencies';
>
>async function exec() {
>  ......
>  ......
>  const rootFile = pkg.getRootFilePath();
>  if (rootFile) {
>+    try {
>       // 在当前进程中调用
>       require(rootFile).call(null, Array.from(arguments))
>+    } catch (e) {
>+      log.error(e.message)
>+    }
>
>  }
>}
>
>module.exports = exec;
>```



在models/command/lib/index.js中实现参数初始化

```js
'use strict';

const log = require('@ijianglu/log')
const colors = require('colors/safe');
const semver = require('semver');

class Command {
    constructor(argv) {
+        if (!argv) {
+            throw new Error('参数不能为空！')
+        }
+        if (!Array.isArray(argv)) {
+            throw new Error('参数必须为数组！')
+        }
+        if (argv.length < 1) {
+            throw new Error('参数列表为空！')
+        }
        this._argv = argv;
        console.log(argv)
        // 创建微任务队列，并检查node版本
        let runner = new Promise((resolve, reject) => {
            let chain = Promise.resolve();
            chain = chain.then(() => this.checkNodeVersion())
+            chain = chain.then(() => this.initArgs())
+            chain = chain.then(() => this.init())
+            chain = chain.then(() => this.exec())
            chain.catch(e => {log.error(e.message)})
        })
    }

    checkNodeVersion() {
        const currentVersion = process.version;
        if (!semver.gte(currentVersion, '12.0.0')) {
            throw new Error(colors.red(`cli-dev 需要安装 v12.0.0 以上版本的 Node.js`))
        }
    }
    
+    initArgs() {
+        this._cmd = this._argv[this._argv.length - 1];
+        this._argv = this._argv.slice(0, this._argv.length - 1)
+    }

    init() {
        throw new Error('init必须实现')
    }

    exec() {
        throw new Error('exec必须实现')
    }
}

module.exports = Command;
```

**使用继承的方式把每个进程自己的部分写在InitCommand中；公共参数封装到公共类Command中**

```js
'use strict';

const Command = require('@ijianglu/command')
+ const log = require('@ijianglu/log')

// 使用继承的方式把每个进程自己的部分写在InitCommand中；公共参数封装到公共类Command中
class InitCommand extends Command {
+	init() {
+        this.projectName = this._argv[0] || '';
+        this.force = !!this._cmd.force;
+        log.verbose('project name', this.projectName)
+        log.verbose('force', this.force)
+    }
    
+    exec() {
+       console.log('init的业务逻辑') 
+    }
}

// 此处形参与commander注册命令的action参数一致
function init(argv) {
    // console.log('init', projectName, cmdObj.force, cmdObj.parent.targetPath)
    return new InitCommand(argv);
}

module.exports = init;
module.exports.InitCommand = InitCommand;
```

