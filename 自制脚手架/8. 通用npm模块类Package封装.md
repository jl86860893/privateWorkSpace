





# 通用npm模块类Package封装

## 脚手架本地调试

配置本地调试路径。路径存在运行环境中

```js
program
    //.name(Object.keys(pkg.bin)[0])
    //.usage('<command> [options]')
    //.version(pkg.version)
    //.option('-d, --debug', '是否开启调试模式', false)
    .option('-tp, --targetPath <targetPath>', '是否指定本地调试文件路径', '');

// 指定targetPath
program.on('option:targetPath', function() {
    process.env.CLI_TARGET_PATH = program.targetPath;
});
```

## 动态执行库exec模块创建

在`core`下执行 `lerna create @ijianglu/exec`

然后在`core/cli`的package.json中引入；最后`npm link`一下



替换init，改为exec

```js
const exec = require('@ijianglu/exec');

// ......

function registerCommand() {
    // ...
    
    program
        .command('init [projectName]')
        .option('-f, --force', '是否强制初始化项目')
        .action(exec);

    // ...
}
```

`node -e "require('./core/cli/bin/index.js')"`可直接执行某一个模块

## 创建npm模块通用类Package

targetPAth --> modulePath  --> Package(npm模块)

Package.getRootFile(获取入口文件)

Package.update ...方法

##### package:创建Package包

在models下创建package  `lerna create @ijianglu/Package`

并写入初始化方法：

```js
const path = require('path');
const pkgDir = require('pkg-dir').sync;

class Package {
	constructor(options) {
		if (!options) {
          throw new Error('Package类的options参数不能为空！');
        }
        if (!isObject(options)) {  // isObject为封装或用lodash
          throw new Error('Package类的options参数必须为对象！');
        }
        // package的目标路径
        this.targetPath = options.targetPath;
        // 缓存package的路径
        this.storeDir = options.storeDir;
        // package的name
        this.packageName = options.packageName;
        // package的version
        this.packageVersion = options.packageVersion;
    }
    
    // 判断当前Package是否存在
  	exists() {}
    
    // 安装Package
  	install() {}
    
    // 更新Package
  	update() {}
    
    // 获取入口文件的路径
  	getRootFilePath() {}
}
```

##### exec:在core/exec入口文件执行

```js
'use strict';

const path = require('path');
const Package = require('@ijianglu/package');
const log = require('@ijianglu/log');

const SETTINGS = {
  init: '@ijianglu/init',
};

const CACHE_DIR = 'dependencies';

async function exec() {
    let targetPath = process.env.CLI_TARGET_PATH;
    const homePath = process.env.CLI_HOME;
    let storeDir = '';
    let pkg;
    log.verbose('targetPath', targetPath);
    log.verbose('homePath', homePath);
    // exec执行参数为arguments，arguments最后一个参数为命令的对象
    const cmdObj = arguments[arguments.length - 1];
    // 通过命令对象的name属性获取指令的名称，如init命令
    const cmdName = cmdObj.name();
    // 通过命令与包名的映射关系获取packageName
    const packageName = SETTINGS[cmdName];
    const packageVersion = 'latest';
    if (!targetPath) {
       // 如果在命令行执行时未设置指定本地调试文件路径，即未执行--targetPath时。则需要设置缓存路径
        targetPath = path.resolve(homePath, CACHE_DIR); // 生成缓存路径
        storeDir = path.resolve(targetPath, 'node_modules');
        log.verbose('targetPath', targetPath);
        log.verbose('storeDir', storeDir);
        pkg = new Package({
          targetPath,
          storeDir,
          packageName,
          packageVersion,
        });
        if (await pkg.exists()) {
          // 更新package
          await pkg.update();
        } else {
          // 安装package
          await pkg.install();
        }
    } else {
         pkg = new Package({
          targetPath,
          packageName,
          packageVersion,
        });
    }
    
    // 获取入口文件路径，然后可根据入口文件执行对应代码
    const rootFile = pkg.getRootFilePath();
    
     // cli-dev init --targetPath C:\\Users\\YC01705\\Desktop\\code-demo\\cli-dev\\cli-dev\\commands\\init --debug --force test-project
    // init执行commands/init中package对应的main入口文件，即commands/init/lib/init.js
    // require(rootFile)则执行init.js中的init方法
    // require(rootFile).apply(null, Array.from(arguments))  则改变this指向并传递参数
    if (rootFile) {
       //根据入口文件传递参数，并执行对应代码
        require(rootFile).call(null, Array.from(arguments));
    }
}
```

##### package:获取文件入口路径

在models/package下`npm install pkg-dir`

```js
const pkgDir = require('pkg-dir').sync;

class Package {
	// ......
    
    // 获取入口文件的路径
    getRootFilePath() {
        // 1. 获取package.json所在目录
            const dir = pkgDir(targetPath);
        if (dir) {
            // 2. 读取package.json
            const pkgFile = require(path.resolve(dir, 'package.json'));
            // 3. 寻找main/lib
            if (pkgFile && pkgFile.main) {
            // 4. 路径的兼容(macOS/windows)
            return formatPath(path.resolve(dir, pkgFile.main));
            }
        }
        return null;
    }
}


```

路径的兼容(macOS/windows)`lerna create @ijianglu/format-path utils`

```js
'use strict';

const path = require('path');

module.exports = function formatPath(p) {
  if (p && typeof p === 'string') {
    const sep = path.sep;
    if (sep === '/') {
      return p;
    } else {
      return p.replace(/\\/g, '/');
    }
  }
  return p;
}
```

##### package:安装package:alarm_clock:

`npm install -S npminstall`

```js
// 使用方法
const npminstall = require('npminstall')
const path = require('path')

npminstall({
	root: path.resolve(__dirname, '.jl-cli-dev'),
	storeDir: path.resolve(__dirnam, '.jl-cli-dev', 'node_modules'),
	registry: 'https://registry.npmjs.org',
	pkgs: [
		{ name: '@ijianglu/utils', version: '~1.0.1' },
	]
});
```

执行后将生成对应的包与缓存目录

![](C:\Users\YC01705\Desktop\脚手架架构学习\pic\package流程\npminstall库执行后.png)

```js
const npminstall = require('npminstall');
const { getDefaultRegistry } = require('@ijianglu/get-npm-info');

// 安装Package
install() {
	return npminstall({
      root: this.targetPath,
      storeDir: this.storeDir,
      registry: getDefaultRegistry(),
      pkgs: [{
        name: this.packageName,
        version: this.packageVersion,
      }],
    });
}
```

##### package中通过npminstall缓存路径改造package:panda_face::anchor:

`npm install fs-extra`

### Async

- [copy](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/copy.md)
- [emptyDir](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/emptyDir.md)
- [ensureFile](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/ensureFile.md)
- [ensureDir](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/ensureDir.md)
- [ensureLink](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/ensureLink.md)
- [ensureSymlink](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/ensureSymlink.md)
- [mkdirp](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/ensureDir.md)
- [mkdirs](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/ensureDir.md)
- [move](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/move.md)
- [outputFile](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/outputFile.md)
- [outputJson](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/outputJson.md)
- [pathExists](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/pathExists.md)
- [readJson](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/readJson.md)
- [remove](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/remove.md)
- [writeJson](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/writeJson.md)

### Sync

- [copySync](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/copy-sync.md)
- [emptyDirSync](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/emptyDir-sync.md)
- [ensureFileSync](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/ensureFile-sync.md)
- [ensureDirSync](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/ensureDir-sync.md)
- [ensureLinkSync](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/ensureLink-sync.md)
- [ensureSymlinkSync](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/ensureSymlink-sync.md)
- [mkdirpSync](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/ensureDir-sync.md)
- [mkdirsSync](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/ensureDir-sync.md)
- [moveSync](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/move-sync.md)
- [outputFileSync](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/outputFile-sync.md)
- [outputJsonSync](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/outputJson-sync.md)
- [pathExistsSync](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/pathExists-sync.md)
- [readJsonSync](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/readJson-sync.md)
- [removeSync](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/remove-sync.md)
- [writeJsonSync](https://github.com/jprichardson/node-fs-extra/blob/HEAD/docs/writeJson-sync.md)

```js
'use strict';

const path = require('path');
const fse = require('fs-extra');
const pkgDir = require('pkg-dir').sync;
const pathExists = require('path-exists').sync;
const npminstall = require('npminstall');
const { isObject } = require('@ijianglu/utils');
const formatPath = require('@ijianglu/format-path');
const { getDefaultRegistry, getNpmLatestVersion } = require('@ijianglu/get-npm-info');

class Package {
  constructor(options) {
    if (!options) {
      throw new Error('Package类的options参数不能为空！');
    }
    if (!isObject(options)) {
      throw new Error('Package类的options参数必须为对象！');
    }
    // package的目标路径
    this.targetPath = options.targetPath;
    // 缓存package的路径
    this.storeDir = options.storeDir;
    // package的name
    this.packageName = options.packageName;
    // package的version
    this.packageVersion = options.packageVersion;
    // package的缓存目录前缀
    this.cacheFilePathPrefix = this.packageName.replace('/', '_');
  }

  async prepare() {
    if (this.storeDir && !pathExists(this.storeDir)) {
      // 缓存路径不存在文件夹，则创建
      fse.mkdirpSync(this.storeDir);
    }
    if (this.packageVersion === 'latest') {
      this.packageVersion = await getNpmLatestVersion(this.packageName);
    }
  }

  get cacheFilePath() {
    return path.resolve(this.storeDir, `_${this.cacheFilePathPrefix}@${this.packageVersion}@${this.packageName}`);
  }

  getSpecificCacheFilePath(packageVersion) {
    return path.resolve(this.storeDir, `_${this.cacheFilePathPrefix}@${packageVersion}@${this.packageName}`);
  }

  // 判断当前Package是否存在
  async exists() {
    if (this.storeDir) {
      await this.prepare();
      return pathExists(this.cacheFilePath);
    } else {
      return pathExists(this.targetPath);
    }
  }

  // 安装Package
  async install() {
    await this.prepare();
    return npminstall({
      root: this.targetPath,
      storeDir: this.storeDir,
      registry: getDefaultRegistry(),
      pkgs: [{
        name: this.packageName,
        version: this.packageVersion,
      }],
    });
  }

  // 更新Package
  async update() {
    await this.prepare();
    // 1. 获取最新的npm模块版本号
    const latestPackageVersion = await getNpmLatestVersion(this.packageName);
    // 2. 查询最新版本号对应的路径是否存在
    const latestFilePath = this.getSpecificCacheFilePath(latestPackageVersion);
    // 3. 如果不存在，则直接安装最新版本
    if (!pathExists(latestFilePath)) {
      await npminstall({
        root: this.targetPath,
        storeDir: this.storeDir,
        registry: getDefaultRegistry(),
        pkgs: [{
          name: this.packageName,
          version: latestPackageVersion,
        }],
      });
      this.packageVersion = latestPackageVersion;
    } else {
      this.packageVersion = latestPackageVersion;
    }
  }

  // 获取入口文件的路径
  getRootFilePath() {
    function _getRootFile(targetPath) {
      // 1. 获取package.json所在目录
      const dir = pkgDir(targetPath);
      if (dir) {
        // 2. 读取package.json
        const pkgFile = require(path.resolve(dir, 'package.json'));
        // 3. 寻找main/lib
        if (pkgFile && pkgFile.main) {
          // 4. 路径的兼容(macOS/windows)
          return formatPath(path.resolve(dir, pkgFile.main));
        }
      }
      return null;
    }
    if (this.storeDir) {
      return _getRootFile(this.cacheFilePath);
    } else {
      return _getRootFile(this.targetPath);
    }
  }
}

module.exports = Package;

```

## get-npm-info类封装

```js
'use strict';

const axios = require('axios');
const urlJoin = require('url-join');
const semver = require('semver');

function getNpmInfo(npmName, registry) {
  if (!npmName) {
    return null;
  }
  const registryUrl = registry || getDefaultRegistry();
  const npmInfoUrl = urlJoin(registryUrl, npmName);
  return axios.get(npmInfoUrl).then(response => {
    if (response.status === 200) {
      return response.data;
    }
    return null;
  }).catch(err => {
    return Promise.reject(err);
  });
}

function getDefaultRegistry(isOriginal = true) {
  return isOriginal ? 'https://registry.npmjs.org' : 'https://registry.npm.taobao.org';
}

async function getNpmVersions(npmName, registry) {
  const data = await getNpmInfo(npmName, registry);
  if (data) {
    return Object.keys(data.versions);
  } else {
    return [];
  }
}

function getSemverVersions(baseVersion, versions) {
  return versions
    .filter(version => semver.satisfies(version, `>${baseVersion}`))
    .sort((a, b) => semver.gt(b, a) ? 1 : -1);
}

async function getNpmSemverVersion(baseVersion, npmName, registry) {
  const versions = await getNpmVersions(npmName, registry);
  const newVersions = getSemverVersions(baseVersion, versions);
  if (newVersions && newVersions.length > 0) {
    return newVersions[0];
  }
  return null;
}

async function getNpmLatestVersion(npmName, registry) {
  let versions = await getNpmVersions(npmName, registry);
  if (versions) {
    return versions.sort((a, b) => semver.gt(b, a) ? 1 : -1)[0];
  }
  return null;
}

module.exports = {
  getNpmInfo,
  getNpmVersions,
  getNpmSemverVersion,
  getDefaultRegistry,
  getNpmLatestVersion,
};
```

