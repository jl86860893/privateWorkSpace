# 使用多进程

`models/command/lib/index.js`

```js
'use strict';

const path = require('path');
const Package = require('@ijianglu/package');
const log = require('@ijianglu/log');
+ const cp = require('child_process')
// const { exec: spawn } = require('@ijianglu/utils');

const SETTINGS = {
  init: '@ijianglu/init',
};

const CACHE_DIR = 'dependencies';

async function exec() {
  let targetPath = process.env.CLI_TARGET_PATH;
  const homePath = process.env.CLI_HOME;
  let storeDir = '';
  let pkg;
  log.verbose('targetPath', targetPath);
  log.verbose('homePath', homePath);

  const cmdObj = arguments[arguments.length - 1];
  const cmdName = cmdObj.name();
  const packageName = SETTINGS[cmdName];
  const packageVersion = 'latest';

  if (!targetPath) {
    console.log(homePath, '111111111111111')
    targetPath = path.resolve(homePath, CACHE_DIR); // 生成缓存路径
    storeDir = path.resolve(targetPath, 'node_modules');
    log.verbose('targetPath', targetPath);
    log.verbose('storeDir', storeDir);
    pkg = new Package({
      targetPath,
      storeDir,
      packageName,
      packageVersion,
    });
    if (await pkg.exists()) {
      // 更新package
      await pkg.update();
    } else {
      // 安装package
      await pkg.install();
    }
  } else {
    pkg = new Package({
      targetPath,
      packageName,
      packageVersion,
    });
  }
  // cli-dev init --targetPath C:\\Users\\YC01705\\Desktop\\code-demo\\cli-dev\\cli-dev\\commands\\init --debug --force test-project
  // init执行commands/init中package对应的main入口文件，即commands/init/lib/init.js
  // require(rootFile)则执行init.js中的init方法
  // require(rootFile).apply(null, Array.from(arguments))  则改变this指向并传递参数
  const rootFile = pkg.getRootFilePath();
  if (rootFile) {
    try {
      // 在当前进程中调用
-      // require(rootFile).call(null, Array.from(arguments))
+      const code = 'console.log(1)'
+      const child = cp.spawn('node', ['-e', code], {
+        cwd: process.cwd(),
+    	 // stdio默认为pipe，需要手写通信逻辑。inherit则不用
+        stdio: 'inherit'
+      })
+      child.on('error', e => {
+        log.error(e.message)
+        process.exit(1)
+      })
+      child.on('exit', e => {
+        log.verbose('命令执行成功' + e)
+        process.exit(e)
+      })
    } catch (e) {
      log.error(e.message)
    }

  }
}

module.exports = exec;
```

# 生成多进程执行的代码

如果将上述需要执行的代码`require(rootFile).call(null, Array.from(arguments))`放入子进程执行。难点在于Array.from(arguments)如何执行

```js
if (rootFile) {
    try {
+      const args = Array.from(arguments);
+      const cmd = args[args.length - 1];
+      const o = Object.create(null);
+      Object.keys(cmd).forEach(key => {
+          if (
+              // 去掉原型链上的属性
+              cmd.hasOwnProperty(key) &&
+               // 去掉冗余私有属性
+              !key.startsWith('_') &&
+              // 去掉命令的parent中的属性
+              key !== 'parent'
+          ) {
+              o[key] = cmd[key];
+          }
+      })
+      args[args.length - 1] = o;
+      const code = `require('${rootFile}').call(null, ${JSON.stringify(args)})`
      const child = cp.spawn('node', ['-e', code], {
        cwd: process.cwd(),
    	 // stdio默认为pipe，需要手写通信逻辑。inherit则不用
        stdio: 'inherit'
      })
      child.on('error', e => {
        log.error(e.message)
        process.exit(1)
      })
      child.on('exit', e => {
        log.verbose('命令执行成功' + e)
        process.exit(e)
      })
    } catch (e) {
      log.error(e.message)
    }

  }
```

# windows系统spawn兼容

cp.spawn用spawn函数

```js
function spawn(command, args, options) {
    const win32 = process.platform === 'win32';
    
    const cmd = win32 ? 'cmd': command;
    const cmdArgs = win32 ? ['/c'].concat(command, args): args;
    // spawn('cmd', ['/c', 'node', code], {cwd: process.cwd(),stdio: 'inherit'})
    return cp.spawn(cmd, cmdArgs, options || {})
}
```

